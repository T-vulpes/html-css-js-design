<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falling Sand Game</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background-color: #111;
            overflow: hidden;
            touch-action: none; 
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            border: 1px solid #333;
            cursor: crosshair;
            image-rendering: pixelated; 
        }
        .instruction {
            position: absolute;
            top: 20px;
            color: rgba(255, 255, 255, 0.5);
            font-family: sans-serif;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
    </style>
</head>
<body>

    <div class="instruction">Click & Drag to Draw Sand</div>
    <canvas id="sandbox"></canvas>

    <script>
        const canvas = document.getElementById('sandbox');
        const ctx = canvas.getContext('2d');
        const grainSize = 10; 
        let cols, rows;
        let grid;
        let hueValue = 0; n
        function setup() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            cols = Math.floor(canvas.width / grainSize);
            rows = Math.floor(canvas.height / grainSize);            
            grid = make2DArray(cols, rows);
        }

        function make2DArray(cols, rows) {
            let arr = new Array(cols);
            for (let i = 0; i < arr.length; i++) {
                arr[i] = new Array(rows).fill(0);
            }
            return arr;
        }

        let isDrawing = false;
        canvas.addEventListener('mousedown', () => isDrawing = true);
        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                let mouseCol = Math.floor(e.clientX / grainSize);
                let mouseRow = Math.floor(e.clientY / grainSize);
                let matrix = 3; 
                let extent = Math.floor(matrix / 2);
                
                for (let i = -extent; i <= extent; i++) {
                    for (let j = -extent; j <= extent; j++) {
                        let col = mouseCol + i;
                        let row = mouseRow + j;
                        if (col >= 0 && col < cols && row >= 0 && row < rows) {
                            if (Math.random() > 0.1) { 
                                grid[col][row] = hueValue; 
                            }
                        }
                    }
                }
                hueValue += 1;
                if (hueValue > 360) hueValue = 0;
            }
        });

        canvas.addEventListener('touchstart', () => isDrawing = true);
        canvas.addEventListener('touchend', () => isDrawing = false);
        canvas.addEventListener('touchmove', (e) => {
            if (isDrawing) {
                let touch = e.touches[0];
                let mouseCol = Math.floor(touch.clientX / grainSize);
                let mouseRow = Math.floor(touch.clientY / grainSize);
                if (mouseCol >= 0 && mouseCol < cols && mouseRow >= 0 && mouseRow < rows) {
                    grid[mouseCol][mouseRow] = hueValue;
                    hueValue += 2;
                }
            }
        });

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            let nextGrid = make2DArray(cols, rows);
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    let state = grid[i][j];

                    if (state > 0) {
                        ctx.fillStyle = `hsl(${state}, 100%, 50%)`;
                        ctx.fillRect(i * grainSize, j * grainSize, grainSize, grainSize);

                        let below = j + 1;
                        if (below < rows) {                            
                            let belowIsFree = grid[i][below] === 0;                            
                            if (belowIsFree) {
                                nextGrid[i][below] = state;
                            } else {
                                let dir = Math.random() < 0.5 ? -1 : 1; 
                                let infoA = i + dir;
                                let infoB = i - dir;

                                if (infoA >= 0 && infoA < cols && grid[infoA][below] === 0) {
                                    nextGrid[infoA][below] = state;
                                } 
                                else if (infoB >= 0 && infoB < cols && grid[infoB][below] === 0) {
                                    nextGrid[infoB][below] = state;
                                } 
                                else {
                                    nextGrid[i][j] = state;
                                }
                            }
                        } else {
                            nextGrid[i][j] = state;
                        }
                    }
                }
            }

            grid = nextGrid;

            requestAnimationFrame(draw);
        }

        setup();
        draw();        
        window.addEventListener('resize', setup);

    </script>

</body>

</html>


